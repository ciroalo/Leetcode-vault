Tags: [[Array]], [[Dynamic Programming]], [[Intervals]], [[Greedy]], [[Sorting]]
Difficulty: [[Medium]]
## Problem
Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Note** that intervals which only touch at a point are **non-overlapping**. For example, `[1, 2]` and `[2, 3]` are non-overlapping.

**Example 1:**
**Input:** intervals = [ [1,2],[2,3],[3,4],[1,3] ]
**Output:** 1
**Explanation:** [1,3] can be removed and the rest of the intervals are non-overlapping.

**Example 2:**
**Input:** intervals = [ [1,2],[1,2],[1,2] ]
**Output:** 2
**Explanation:** You need to remove two [1,2] to make the rest of the intervals non-overlapping.

**Example 3:**

**Input:** intervals = [ [1,2],[2,3] ]
**Output:** 0
**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping.

**Constraints:**
- `1 <= intervals.length <= 105`
- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 104`

## Solution
For this problem we just to check if the start of the next interval is less than the end of the current interval. If it is, we just keep whichever has the minimum end and add one to the `res` variable (holds the number of intervals to get rid of):

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()

        res = 0
        prevEnd = intervals[0][1]

        for start, end in intervals[1:]:
            if start >= prevEnd:
                prevEnd = end
            else:
                res += 1
                prevEnd = min(prevEnd, end)

        return res
```

![[Pasted image 20250822174009.png]]