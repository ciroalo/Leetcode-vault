Tags: [[Divide and Conquer]], [[Bit Manipulation]]
Difficulty: [[Easy]]
## Problem
Given a positive integer `n`, write a function that returns the number of set bits in its binary representation (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).

**Example 1:**
**Input:** n = 11
**Output:** 3
**Explanation:**
The input binary string **1011** has a total of three set bits.

**Example 2:**
**Input:** n = 128
**Output:** 1
**Explanation:**
The input binary string **10000000** has a total of one set bit.

**Example 3:**
**Input:** n = 2147483645
**Output:** 30
**Explanation:**
The input binary string **1111111111111111111111111111101** has a total of thirty set bits.

**Constraints:**
- `1 <= n <= 231 - 1`

**Follow up:** If this function is called many times, how would you optimize it?


## Solution
### Goal:
Count how many `1`s are present in the **32-bit binary** representation of the number `n`.
### Breakdown:
1. **`res = 0`**  
    Initializes a counter to track the number of 1-bits.
2. **`for i in range(32)`**  
    Since the input is a 32-bit unsigned integer, we iterate through all 32 bit positions.
3. **`(n >> i) & 1`**
    - `n >> i` shifts the bits of `n` right by `i` positions. This moves the bit at position `i` to the least significant bit (rightmost position).
    - `& 1` then checks whether that bit is `1`. If it is, this expression evaluates to `1`; otherwise, it evaluates to `0`.
4. **`if (n >> i) & 1: res += 1`**  
    If the `i`-th bit is `1`, increment the counter.
5. **`return res`**  
    Returns the total count of `1` bits in the binary representation of `n`.

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        
        for i in range(32):
            if (n >> i) & 1:
                res += 1

        return res
```

![[Pasted image 20251127181812.png]]
