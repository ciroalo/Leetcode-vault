Tags: [[Divide and Conquer]], [[Bit Manipulation]]
Difficulty: [[Easy]]
## Problem
Reverse bits of a given 32 bits signed integer.

**Example 1:**
**Input:** n = 43261596
**Output:** 964176192
**Explanation:**

| Integer   | Binary                           |
| --------- | -------------------------------- |
| 43261596  | 00000010100101000001111010011100 |
| 964176192 | 00111001011110000010100101000000 |

**Example 2:**
**Input:** n = 2147483644
**Output:** 1073741822
**Explanation:**

| Integer    | Binary                           |
| ---------- | -------------------------------- |
| 2147483644 | 01111111111111111111111111111100 |
| 1073741822 | 00111111111111111111111111111110 |

**Constraints:**
- `0 <= n <= 231 - 2`
- `n` is even.

**Follow up:** If this function is called many times, how would you optimize it?

## Solution
In this case, we create the reverse variable that will hold the reversed number initialized at zero. The reason being is that we are gonna keep moving that number bit related wise to the left, while we add the last bit of the `n` number. After that we move bit wise the `n` number to the right, getting the next bit for the operation. Then we just return the new reversed variable:

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        reversed_n = 0

        for _ in range(32):
            reversed_n = (reversed_n << 1) | (n & 1)
            n >>= 1

        return reversed_n
```

![[Pasted image 20260211155817.png]]
