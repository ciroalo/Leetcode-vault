Tags: [[Array]], [[Dynamic Programming]], [[Greedy]]
Difficulty: [[Medium]]
## Problem
You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at index 0.

Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at index `i`, you can jump to any index `(i + j)` where:

- `0 <= j <= nums[i]` and
- `i + j < n`

Return _the minimum number of jumps to reach index_ `n - 1`. The test cases are generated such that you can reach index `n - 1`.

**Example 1:**
**Input:** nums = [2,3,1,1,4]
**Output:** 2
**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.

**Example 2:**
**Input:** nums = [2,3,0,1,4]
**Output:** 2

**Constraints:**
- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- It's guaranteed that you can reach `nums[n - 1]`.

## My Solution
I created an array with the costs of getting to every step, starting from the front to the end, then returning the last step value:

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [n] * n
        dp[0] = 0

        for i in range(n):
            for j in range(1, nums[i]+1):
                if (i + j) < n:
                    dp[i + j] = min(dp[i + j], dp[i] + 1)

        return dp[n-1]
```

![[Pasted image 20250903192513.png]]

## Greedy Solution

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        res = 0
        l = r = 0

        while r < len(nums) - 1:
            farthest = 0
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])

            l = r + 1
            r = farthest
            res += 1

        return res
```

![[Pasted image 20250903235234.png]]