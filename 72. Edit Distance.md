Tags: [[Dynamic Programming]], [[String]]
Difficulty: [[Medium]]
## Problem
Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.

You have the following three operations permitted on a word:
- Insert a character
- Delete a character
- Replace a character

**Example 1:**
**Input:** word1 = "horse", word2 = "ros"
**Output:** 3
**Explanation:** 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

**Example 2:**
**Input:** word1 = "intention", word2 = "execution"
**Output:** 5
**Explanation:** 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

**Constraints:**
- `0 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of lowercase English letters.

## Brute-force Solution
We can use brute force for this type of problem, but we will see next the problems we encounter. For this problem we are gonna keep track of the indexes in both words (`i` and `j`) and another to keep count of the number of operations `ops` so far. For `word1` we will use `i` and for `word2` we will use `j`. So we will encounter two states:
1. When `word1[i]` is equal to `word2[j]`: In that case we add `1` both to `i` and `j` and keep `ops` as it is.
2.  When `word1[i]` is not equal to `word2[j]`: Then we will make use of the different operations we have and add `1` to the number of operations they return:
	1. **Replace**: for this one we will increment both `i` and `j` with one because it will act as if the character in that index is already the one we need.
	2. **Delete**: in this one we will only increment `i` because `j` has not been matched yet.
	3. **Insert**: in this one we will only increment `j` because `i` has not been processed yet.

`

```python
class Solution:
    output = 40
    def minDistance(self, word1: str, word2: str) -> int:
        def recursion(i, j, ops):
            if ops >= self.output:
                return

            if i == len(word1) and j == len(word2):
                self.output = ops
                return

            if i == len(word1):
                self.output = min(self.output, ops + (len(word2) - j))
                return

            if j == len(word2):
                self.output = min(self.output, ops + (len(word1) - i))
                return

            if word1[i] == word2[j]:
                recursion(i + 1, j + 1, ops)
            else:
                # replace
                recursion(i + 1, j + 1, ops + 1)

                # delete
                recursion(i + 1, j, ops + 1)

                # insert
                recursion(i, j + 1, ops + 1)
    

        recursion(0, 0, 0)
        return self.output
```


The problem with this solution is that it is not very time efficient:

![[Pasted image 20251114135355.png]]

## 2-D Dynamic Programming Solution
We will use the idea behind the brute force solution and adapt it to a 2d array:

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        cache = [ [float("inf")] * (len(word2) + 1) for i in range(len(word1) + 1)]

        for j in range(len(word2) + 1):
            cache[len(word1)][j] = len(word2) - j
        for i in range(len(word1) + 1):
            cache[i][len(word2)] = len(word1) - i

        for i in range(len(word1) - 1, -1, -1):
            for j in range(len(word2) - 1, -1, -1):
                if word1[i] == word2[j]:
                    cache[i][j] = cache[i+1][j+1]
                else:
                    cache[i][j] = 1 + min(cache[i+1][j+1], cache[i][j+1], cache[i+1][j])

        return cache[0][0]
```

![[Pasted image 20251114135553.png]]
