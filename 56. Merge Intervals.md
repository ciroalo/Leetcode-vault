Tags: [[Intervals]], [[Array]], [[Sorting]]
Difficulty: [[Medium]]
## Problem
Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**
**Input:** intervals = [ [1,3],[2,6],[8,10],[15,18] ]
**Output:** [ [1,6],[8,10],[15,18] ]
**Explanation:** Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

**Example 2:**
**Input:** intervals = [ [1,4],[4,5] ]
**Output:** [ [1,5] ] 
**Explanation:** Intervals [1,4] and [4,5] are considered overlapping.

**Constraints:**
- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

## My Solution
First we are gonna sort the array with the first value of each interval in ascending order and we create a `res` list to return.

With that we can take the first interval and check if the next interval first value is less than the second value of our `current` interval. If it is, we update the max value of the `current` interval. If it's not, we add `current` to `res` and update `current` to the next interval.

At the end we append that last `current` interval to `res` and return `res`:

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        res = []

        intervals = sorted(intervals, key=lambda x: x[0])
        current = intervals[0]

        for i in range(1, len(intervals)):
            inter = intervals[i]
            if inter[0] <= current[1]:
                current[1] = max(current[1], inter[1])
            else:
                res.append(current)
                current = inter
        
        res.append(current)
        return res
            
```

![[Pasted image 20250821110800.png]]