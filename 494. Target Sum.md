Tags: [[Array]], [[Dynamic Programming]], [[Backtracking]]
Difficulty: [[Medium]]
## Problem
You are given an integer array `nums` and an integer `target`.

You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.
- For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `"+2-1"`.

Return the number of different **expressions** that you can build, which evaluates to `target`.

**Example 1:**
**Input:** nums = [1,1,1,1,1], target = 3
**Output:** 5
**Explanation:** There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

**Example 2:**
**Input:** nums = [1], target = 1
**Output:** 1

**Constraints:**
- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

## Solution
### Recursive Solution
We will start this problem following a recursive solution. For that we will create a recursive function in our case called `recursion` where we will pass as an argument the current index in the array and the current sum of elements.

In the `recursion` method we first check if we have traversed all the array of numbers, then we check if the current sum its equal to the target, if yes, we return 1, if not, we return 0.

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def recursion(i, total):
            if i >= len(nums):
                return 1 if target == total else 0
            
            # + 
            result = recursion(i + 1, total + nums[i])
            # -
            result += recursion(i + 1, total + (-1)*nums[i])

            return result

        return recursion(0, 0)
```

While this solution works, it *doesn't pass the tests*. The reason being is that it is not very time efficient because we end up computing the same things all over again. To fix that, we need to apply `memoization` to the mix:

### Memoization
To apply memoization to the mix we are gonna create a hash-map that will store the `index` position and the current sum as a tuple, so we don't have to compute again all the possibilities.

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        dp = {}

        def recursion(i, total):
            if (i, total) in dp:
                return dp[(i, total)]

            if i >= len(nums):
                return 1 if target == total else 0
            
            result = recursion(i + 1, total + nums[i])
            result += recursion(i + 1, total + (-1)*nums[i])

            dp[(i, total)] = result
            return result

        return recursion(0, 0)
```

![[Pasted image 20251014172437.png]]

As we can see we finally pass the tests.

### 2-D Dynamic Programming
We can even further it by applying a `dynamic programming` with a `2-d` approach. It will work in the following manner:

![[Pasted image 20251014173412.png]]

This is just a drawing to better explain it, but for the real deal we just need to keep 2 rows, the current and the next one:

#### All rows
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        dp = [defaultdict(int) for _ in range(len(nums) + 1)]
        dp[0][0] = 1 # The is one way to get to 0 elements and 0 sum

        for i in range(len(nums)):
            for cur_sum, count in dp[i].items():
                dp[i + 1][cur_sum + nums[i]] += count
                dp[i + 1][cur_sum - nums[i]] += count

        return dp[len(nums)][target]
```

![[Pasted image 20251014175039.png]]

#### Two Rows
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        dp = defaultdict(int)
        dp[0] = 1

        for i in range(len(nums)):
            next_dp = defaultdict(int)
            for cur_sum, count in dp.items():
                next_dp[cur_sum + nums[i]] += count
                next_dp[cur_sum - nums[i]] += count

            dp = next_dp

        return dp[target]
```

![[Pasted image 20251014175416.png]]

