Tags: [[Math]], [[Dynamic Programming]], [[Combinatorics]]
Difficulty: [[Medium]]
## Problem
There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.

Given the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.

The test cases are generated so that the answer will be less than or equal to `2 * 109`.

**Example 1:**
![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

**Input:** m = 3, n = 7
**Output:** 28

**Example 2:**
**Input:** m = 3, n = 2
**Output:** 3
**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down

**Constraints:**
- `1 <= m, n <= 100`


## My Solution
I used a dynamic solutions approach. We know that from one tile we can only go down or right, so we can deduce that the number of ways to reach the end is by adding the different ways to go from the right tile and the downward tile:

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # create dp matrix
        cols, rows = n, m
        dp = [[0 for _ in range(cols)] for _ in range(rows)]
        dp[rows-1][cols-1] = 1

        # populate dp matrix
        for row in range(rows - 1, -1, -1):
            for col in range(cols - 1, -1, -1):
                if row == rows -1 and col == cols -1:
                    continue

                right = dp[row][col + 1] if col + 1 < n else 0
                down  = dp[row + 1][col] if row + 1 < m else 0
                
                dp[row][col] = right + down

        return dp[0][0]
```

![[Pasted image 20250922140323.png]]

## More Efficient Solution
We can take the last solution algorithm and make it more efficient by taking into account that the most outwards row and column will always be 1, so we don't need to take into account the previous : `dp[row][col + 1] if col + 1 < n else 0` or checking if we are at the last element in every loop:

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        cols, rows = n, m
        dp = [[1 for _ in range(cols)] for _ in range(rows)]

        for row in range(1, rows):
            for col in range(1, cols):
                dp[row][col] = dp[row - 1][col] + dp[row][col - 1]

        return dp[rows - 1][cols - 1]
```

![[Pasted image 20250922141047.png]]

 And to make it more memory efficient we don't need to precompute all the rows, we just need to create two, the current one and the previous one.