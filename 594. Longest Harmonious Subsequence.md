Tags: [[Array]], [[HashTable]], [[Sliding Window]], [[Counting]], [[Sorting]]
Difficulty: [[Easy]]
## Problem
We define a harmonious array as an array where the difference between its maximum value and its minimum value is **exactly** `1`.

Given an integer array `nums`, return the length of its longest harmonious subsequence among all its possible subsequences.

**Example 1:**
**Input:** nums = [1,3,2,2,5,2,3,7]
**Output:** 5
**Explanation:**
The longest harmonious subsequence is `[3,2,2,2,3]`.

**Example 2:**
**Input:** nums = [1,2,3,4]
**Output:** 2
**Explanation:**
The longest harmonious subsequences are `[1,2]`, `[2,3]`, and `[3,4]`, all of which have a length of 2.

**Example 3:**
**Input:** nums = [1,1,1,1]
**Output:** 0
**Explanation:**
No harmonic subsequence exists.

**Constraints:**
- `1 <= nums.length <= 2 * 104`
- `-109 <= nums[i] <= 109`

## Solution
I created a hash map where I kept count of the number of times a certain number appears, then I just check for every item in the hash map if the next value exist, if yes I keep the maximum between the current max value and the new one:

```python
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        hash_map = {}
        output = 0

        for n in nums:
            if n not in hash_map:
                hash_map[n] = 0
            hash_map[n] += 1

        for n, count in hash_map.items():
            if (n+1) in hash_map:
                output = max(output, count + hash_map[n+1])

        return output
```

![[Pasted image 20251125174310.png]]

To optimize it we can just make use of the python method `Counter()` to count the repetition of numbers.