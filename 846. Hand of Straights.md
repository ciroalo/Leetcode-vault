Tags: [[Array]], [[HashTable]], [[Greedy]], [[Sorting]]
Difficulty: [[Medium]]
## Problem
Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards.

Given an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise.

**Example 1:**
**Input:** hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
**Output:** true
**Explanation:** Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]

**Example 2:**
**Input:** hand = [1,2,3,4,5], groupSize = 4
**Output:** false
**Explanation:** Alice's hand can not be rearranged into groups of 4.

**Constraints:**
- `1 <= hand.length <= 104`
- `0 <= hand[i] <= 109`
- `1 <= groupSize <= hand.length`

**Note:** This question is the same as 1296: [https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/](https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/)

## Solution
First, we have to realize that for this to work, we need to start at the lowest integer, because there won't be any combination possible that will let us place that integer elsewhere. So to always get the lowest integer possible, we will create a `min heap`. 

Then we will count the number of apparitions of a certain integer with a count map `count = Counter(map)`. This way every time we process an element, we substract it from the count map. But there could come up a problem that there is an element in the middle of the group that doesn't have no more elements left while the previous have, as we can deduce, that will make it impossible to complete, so we check if element with count zero its the lowest, if its not we return `False` and if it is, we just pop it from the min heap:

```python
class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        if len(hand) % groupSize:
            return False


        count = Counter(hand)
        minH = list(count.keys())
        heapq.heapify(minH)

        while minH:
            first = minH[0]

            for i in range(first, first + groupSize):
                if i not in count:
                    return False
                
                count[i] -= 1
                if count[i] == 0:
                    if i != minH[0]:
                        return False
                    heapq.heappop(minH)
            
        return True
```


![[Pasted image 20250905145003.png]]

