Tags: [[Depth-First Search]], [[Breadth-First Search]], [[Graph]], [[Heap (Priority Queue)]], [[Shortest path]]
Difficulty: [[Medium]]
## Problem
You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.

We will send a signal from a given node `k`. Return _the **minimum** time it takes for all the_ `n` _nodes to receive the signal_. If it is impossible for all the `n` nodes to receive the signal, return `-1`.

**Example 1:**
![](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

**Input:** times = [ [2,1,1],[2,3,1],[3,4,1] ], n = 4, k = 2
**Output:** 2

**Example 2:**
**Input:** times = [ [1,2,1] ], n = 2, k = 1
**Output:** 1

**Example 3:**
**Input:** times = [ [1,2,1] ], n = 2, k = 2
**Output:** -1

**Constraints:**
- `1 <= k <= n <= 100`
- `1 <= times.length <= 6000`
- `times[i].length == 3`
- `1 <= ui, vi <= n`
- `ui != vi`
- `0 <= wi <= 100`
- All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)

## Solution
The solution for this problem is to use the Dijsktra's Algorithm. First we map the edges connections from `u` to `v` with the corresponding `w` time. After that we will create a min heap where we will first pick the next node with the less time of connection. After processing it and the edges of that node, we will return the time only if the `visited` set is equal in len as the number of nodes, `-1` otherwise:

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        edges = defaultdict(list)

        for u, v, w in times:
            edges[u].append((v, w))

        minHeap = [(0, k)]
        heapq.heapify(minHeap)
        visited = set()
        t = 0

        while minHeap:
            w1, n1 = heapq.heappop(minHeap)
            if n1 in visited:
                continue

            visited.add(n1)
            t = max(t, w1)

            for n2, w2 in edges[n1]:
                if n2 not in visited:
                    heapq.heappush(minHeap, (w1 + w2, n2))

        return t if len(visited) == n else -1
```

![[Pasted image 20250914203954.png]]

